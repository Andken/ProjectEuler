# Problem 61
# 
# Triangle, square, pentagonal, hexagonal, heptagonal, and octagonal numbers are all figurate (polygonal) numbers and are generated by the following formulae:
# 
# Triangle   	  P3,n=n(n+1)/2		  	     1, 3, 6, 10, 15, ...
# Square		   				     P4,n=n2   	  1, 4, 9, 16, 25, ...
# Pentagonal					      		  P5,n=n(3n1)/2		1, 5, 12, 22, 35, ...
# Hexagonal							   			P6,n=n(2n1)    	  1, 6, 15, 28, 45, ...
# Heptagonal										 		  P7,n=n(5n3)/2	    1, 7, 18, 34, 55, ...
# Octagonal												   		    P8,n=n(3n2)	      1, 8, 21, 40, 65, ...
# The ordered set of three 4-digit numbers: 8128, 2882, 8281, has three interesting properties.
# 
# The set is cyclic, in that the last two digits of each number is the first two digits of the next number (including the last number with the first).
# Each polygonal type: triangle (P3,127=8128), square (P4,91=8281), and pentagonal (P5,44=2882), is represented by a different number in the set.
# This is the only set of 4-digit numbers with this property.
# Find the sum of the only ordered set of six cyclic 4-digit numbers for which each polygonal type: triangle, square, pentagonal, hexagonal, heptagonal, and octagonal, is represented by a different number in the set.
# 
#

import sys

def doubleDigitize(a):
    s = str(a)
    return (int(s[:2]),int(s[2:]))

def reIntergize(a):
    return int(str(a[0]) + str(a[1]))

def polygonalOrderGenerator(polygonalLists):
    if(len(polygonalLists) <= 1):
        yield polygonalLists
    else:
        for permu in polygonalOrderGenerator(polygonalLists[1:]):
            for i in range(len(polygonalLists)):
                yield permu[:i] + polygonalLists[0:1] + permu[i:]

triangle = []
square = []
pentagonal = []
hexagonal = []
heptagonal = []
octagonal = []

current_triangle = 1
n = 1
while(current_triangle < 10000 ):
    if current_triangle >= 1000:
        triangle.append(doubleDigitize(current_triangle))
    current_triangle = n*(n+1)/2
    n=n+1

n = 1
current_square = 1
while(current_square < 10000 ):
    if current_square >= 1000:
        square.append(doubleDigitize(current_square))
    current_square = n*n
    n=n+1

n = 1
current_pentagonal = 1
while(current_pentagonal < 10000 ):
    if current_pentagonal >= 1000:
        pentagonal.append(doubleDigitize(current_pentagonal))
    current_pentagonal = n*(3*n-1)/2
    n=n+1

n = 1
current_hexagonal = 1
while(current_hexagonal < 10000 ):
    if current_hexagonal >= 1000:
        hexagonal.append(doubleDigitize(current_hexagonal))
    current_hexagonal = n*(2*n-1)
    n=n+1

n = 1
current_heptagonal = 1
while(current_heptagonal < 10000 ):
    if current_heptagonal >= 1000:
        heptagonal.append(doubleDigitize(current_heptagonal))
    current_heptagonal = n*(5*n-3)/2
    n=n+1

n = 1
current_octagonal = 1
while(current_octagonal < 10000 ):
    if current_octagonal >= 1000:
        octagonal.append(doubleDigitize(current_octagonal))
    current_octagonal = n*(3*n-2)
    n=n+1


#print triangle
#print square
#print pentagonal
#print hexagonal
#print heptagonal
#print octagonal

num_lists=[]
num_lists.append(triangle)
num_lists.append(square)
num_lists.append(pentagonal)
num_lists.append(hexagonal)
num_lists.append(heptagonal)
num_lists.append(octagonal)

for l in polygonalOrderGenerator(num_lists):
#    print l


    for a in l[0]:
        for b in l[1]:
            if(a[1] == b[0]):
                for c in l[2]:
                    if(b[1] == c[0]):
                        for d in l[3]:
                            if(c[1] == d[0]):
                                for e in l[4]:
                                    if(d[1] == e[0]):
                                        for f in l[5]:
                                            if(e[1] == f[0]):
                                                if(f[1] == a[0]):
                                                    print reIntergize(a)+reIntergize(b)+reIntergize(c)+reIntergize(d)+reIntergize(e)+reIntergize(f)
                                                    sys.exit(0)

